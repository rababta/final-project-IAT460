<!DOCTYPE html>
<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #000;
      font-family: Arial;
    }
    #gui { 
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 8px;
      width: 280px;
    }
    .slider-container {
      margin: 8px 0;
    }
    label {
      display: inline-block;
      width: 100px;
      font-size: 14px;
    }
    input[type="range"] {
      width: 120px;
      vertical-align: middle;
    }
    input[type="color"] {
      width: 30px;
      height: 30px;
      vertical-align: middle;
      margin-left: 5px;
      cursor: pointer;
    }
    button {
      background: #444;
      color: white;
      border: none;
      padding: 6px 12px;
      margin: 5px 2px;
      border-radius: 4px;
      cursor: pointer;
    }
    #instructions {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
    }
    .color-palette {
      display: flex;
      margin: 10px 0;
    }
    .color-option {
      width: 30px;
      height: 30px;
      margin-right: 5px;
      border: 2px solid white;
      border-radius: 4px;
      cursor: pointer;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      text-align: center;
    }
    #startMessage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      text-align: center;
      display: none;
    }
  </style>
</head>
<body>
  <div id="gui">
    <div class="slider-container">
      <label>Density:</label>
      <input type="range" id="density" min="1" max="100" value="30">
    </div>
    <div class="slider-container">
      <label>Particle Size:</label>
      <input type="range" id="particleSize" min="1" max="20" value="5">
    </div>
    <div class="slider-container">
      <label>Pulse:</label>
      <input type="range" id="pulse" min="0" max="100" value="50">
    </div>
    <div class="slider-container">
      <label>Glow:</label>
      <input type="range" id="glow" min="0" max="50" value="25">
    </div>
    <div class="slider-container">
      <label>Formation Speed:</label>
      <input type="range" id="formationSpeed" min="1" max="100" value="50">
    </div>
    
    <div class="slider-container">
      <label>Color Mode:</label>
      <select id="colorMode">
        <option value="single">Single Color</option>
        <option value="multi">Multi Color</option>
        <option value="brightness">Brightness Map</option>
      </select>
    </div>
    
    <div id="singleColorContainer" class="slider-container">
      <label>Base Color:</label>
      <input type="color" id="particleColor" value="#00FFFF">
    </div>
    
    <div id="multiColorContainer" class="color-palette" style="display:none">
      <div class="color-option" style="background:#FF00FF" data-color="#FF00FF"></div>
      <div class="color-option" style="background:#00FFFF" data-color="#00FFFF"></div>
      <div class="color-option" style="background:#FFFF00" data-color="#FFFF00"></div>
      <div class="color-option" style="background:#FF0000" data-color="#FF0000"></div>
      <div class="color-option" style="background:#00FF00" data-color="#00FF00"></div>
      <input type="color" id="customColor" style="display:none">
      <div class="color-option" id="addColor">+</div>
    </div>
    
    <button id="startBtn">START</button>
    <button id="resetBtn">RESET</button>
  </div>
  
  <div id="instructions">
    Drag to rotate | Scroll to zoom | R: Toggle auto-rotate
  </div>

  <div id="loading">Loading assets...</div>
  <div id="startMessage">CLICK START TO BEGIN</div>

  <script>
let agents = [];
let img;
let sound;
let fft;
let isReady = false;
let autoRotate = false;
let rotationX = 0;
let rotationY = 0;
let isDragging = false;
let prevMouseX, prevMouseY;
let formationProgress = 0;
let targetPositions = [];
let beatDetect;
let beatCutoff = 0;
let beatDecayRate = 0.98;
let beatLast = 0;

let params = {
  density: 0.3,
  particleSize: 5,
  pulse: 0.5,
  glow: 25,
  formationSpeed: 50,
  colorMode: "single",
  colors: ["#00FFFF"],
  customColors: ["#FF00FF", "#00FFFF", "#FFFF00", "#FF0000", "#00FF00"]
};

function preload() {
  img = loadImage('reference.png');
  sound = loadSound('loud.mp3');
}

function setup() {
  let canvas = createCanvas(windowWidth, windowHeight, WEBGL);
  document.getElementById('loading').style.display = 'none';
  document.getElementById('startMessage').style.display = 'block';
  
  // UI controls
  document.getElementById('startBtn').onclick = startExperience;
  document.getElementById('resetBtn').onclick = resetSystem;
  
  // Sliders
  document.getElementById('density').oninput = function(e) {
    params.density = e.target.value/100;
    if(isReady) resetSystem();
  };
  document.getElementById('particleSize').oninput = function(e) {
    params.particleSize = parseInt(e.target.value);
    if(isReady) updateParticleSizes();
  };
  document.getElementById('pulse').oninput = function(e) {
    params.pulse = e.target.value/100;
  };
  document.getElementById('glow').oninput = function(e) {
    params.glow = parseInt(e.target.value);
  };
  document.getElementById('formationSpeed').oninput = function(e) {
    params.formationSpeed = parseInt(e.target.value);
  };
  
  // Color mode selector
  document.getElementById('colorMode').onchange = function(e) {
    params.colorMode = e.target.value;
    document.getElementById('singleColorContainer').style.display = 
      params.colorMode === "single" ? "block" : "none";
    document.getElementById('multiColorContainer').style.display = 
      params.colorMode === "multi" ? "flex" : "none";
    if(isReady) updateParticleColors();
  };
  
  // Single color picker
  document.getElementById('particleColor').oninput = function(e) {
    params.colors = [e.target.value];
    if(isReady && params.colorMode === "single") updateParticleColors();
  };
  
  // Multi-color palette
  document.querySelectorAll('.color-option').forEach(function(el) {
    if(el.id !== 'addColor') {
      el.onclick = function() {
        if(params.colorMode === "multi") {
          params.colors = [el.dataset.color];
          updateParticleColors();
        }
      };
    }
  });
  
  // Add color button
  document.getElementById('addColor').onclick = function() {
    document.getElementById('customColor').click();
  };
  document.getElementById('customColor').oninput = function(e) {
    const color = e.target.value;
    params.customColors.push(color);
    const newColor = document.createElement('div');
    newColor.className = 'color-option';
    newColor.style.background = color;
    newColor.dataset.color = color;
    newColor.onclick = function() {
      if(params.colorMode === "multi") {
        params.colors = [this.dataset.color];
        updateParticleColors();
      }
    };
    document.getElementById('multiColorContainer').insertBefore(
      newColor, document.getElementById('addColor')
    );
  };
  
  // Mouse interaction
  canvas.ontouchstart = canvas.onmousedown = function(e) {
    isDragging = true;
    prevMouseX = e.clientX || e.touches[0].clientX;
    prevMouseY = e.clientY || e.touches[0].clientY;
    e.preventDefault();
  };
  
  canvas.ontouchmove = canvas.onmousemove = function(e) {
    if (!isDragging) return;
    let x = e.clientX || e.touches[0].clientX;
    let y = e.clientY || e.touches[0].clientY;
    rotationY += (x - prevMouseX) * 0.01;
    rotationX += (y - prevMouseY) * 0.01;
    prevMouseX = x;
    prevMouseY = y;
    e.preventDefault();
  };
  
  canvas.ontouchend = canvas.onmouseup = function() {
    isDragging = false;
  };
  
  // Visual setup
  noStroke();
  
  // Enhanced audio setup
  fft = new p5.FFT(0.8, 64);
  beatDetect = new p5.PeakDetect(20, 20000, 0.8);
  beatDetect.onPeak(beatDetected);
}

function beatDetected() {
  beatCutoff = 1.0;
  beatLast = millis();
}

function hexToRgb(hex) {
  let r = parseInt(hex.slice(1, 3), 16);
  let g = parseInt(hex.slice(3, 5), 16);
  let b = parseInt(hex.slice(5, 7), 16);
  return [r, g, b];
}

function adjustColorForBrightness(baseColor, brightness) {
  // Convert to HSL for easier brightness adjustment
  let r = baseColor[0] / 255;
  let g = baseColor[1] / 255;
  let b = baseColor[2] / 255;
  
  let max = Math.max(r, g, b);
  let min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
    h = s = 0; // achromatic
  } else {
    let d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  // Adjust lightness based on original pixel brightness
  let targetLightness = map(brightness, 0, 255, 0.1, 0.9);
  
  // Convert back to RGB
  let rgb = HSLToRGB(h, s, targetLightness);
  return [rgb.r * 255, rgb.g * 255, rgb.b * 255];
}

function HSLToRGB(h, s, l) {
  let r, g, b;

  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    let p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return { r: r, g: g, b: b };
}

function updateParticleColors() {
  agents.forEach(function(agent) {
    if(params.colorMode === "single") {
      agent.baseColor = hexToRgb(params.colors[0]);
      agent.color = adjustColorForBrightness(agent.baseColor, agent.brightness);
    } 
    else if(params.colorMode === "multi") {
      const randomColor = params.customColors[floor(random(params.customColors.length))];
      agent.baseColor = hexToRgb(randomColor);
      agent.color = adjustColorForBrightness(agent.baseColor, agent.brightness);
    }
    else if(params.colorMode === "brightness") {
      const hue = map(agent.brightness, 0, 255, 0, 360);
      agent.color = HSVtoRGB(hue/360, 1, 1);
    }
  });
}

function updateParticleSizes() {
  agents.forEach(function(agent) {
    agent.baseSize = map(agent.brightness, 0, 255, 1, params.particleSize);
    agent.size = agent.baseSize;
  });
}

function HSVtoRGB(h, s, v) {
  let r, g, b, i, f, p, q, t;
  i = Math.floor(h * 6);
  f = h * 6 - i;
  p = v * (1 - s);
  q = v * (1 - f * s);
  t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0: r = v, g = t, b = p; break;
    case 1: r = q, g = v, b = p; break;
    case 2: r = p, g = v, b = t; break;
    case 3: r = p, g = q, b = v; break;
    case 4: r = t, g = p, b = v; break;
    case 5: r = v, g = p, b = q; break;
  }
  return [r * 255, g * 255, b * 255];
}

function startExperience() {
  userStartAudio().then(function() {
    sound.loop();
    processImage();
    isReady = true;
    document.getElementById('startMessage').style.display = 'none';
  });
}

function resetSystem() {
  agents = [];
  targetPositions = [];
  formationProgress = 0;
  processImage();
}

function processImage() {
  img.loadPixels();
  img.filter('GRAY');
  img.filter('BLUR', 1);
  
  // First pass: calculate target positions
  for (let y = 0; y < img.height; y += 1) {
    for (let x = 0; x < img.width; x += 1) {
      if (random() > params.density) continue;
      
      let idx = (x + y * img.width) * 4;
      let brightness = img.pixels[idx];
      
      // Store target positions
      targetPositions.push({
        x: (x - img.width/2) * 0.8,
        y: (y - img.height/2) * 0.8,
        z: 0,
        brightness: brightness
      });
    }
  }
  
  // Create agents with random starting positions
  for (let i = 0; i < targetPositions.length; i++) {
    let target = targetPositions[i];
    let startPos = p5.Vector.random3D().mult(random(300, 500));
    
    let color;
    if(params.colorMode === "single") {
      let baseColor = hexToRgb(params.colors[0]);
      color = adjustColorForBrightness(baseColor, target.brightness);
    } 
    else if(params.colorMode === "multi") {
      const randomColor = params.customColors[floor(random(params.customColors.length))];
      let baseColor = hexToRgb(randomColor);
      color = adjustColorForBrightness(baseColor, target.brightness);
    }
    else {
      const hue = map(target.brightness, 0, 255, 0, 360);
      color = HSVtoRGB(hue/360, 1, 1);
    }
    
    agents.push(new Agent(
      startPos.x,
      startPos.y,
      startPos.z,
      color,
      target.brightness,
      target
    ));
  }
  
  updateParticleSizes();
}

function draw() {
  background(0);
  
  if (!isReady) {
    return;
  }
  
  // Handle rotation
  if (autoRotate) rotationY += 0.005;
  rotateX(rotationX);
  rotateY(rotationY);
  
  // Audio analysis
  let spectrum = fft.analyze();
  beatDetect.update(fft);
  
  // Detailed frequency bands
  let bass = fft.getEnergy(20, 140);
  let lowMid = fft.getEnergy(140, 400);
  let mid = fft.getEnergy(400, 2600);
  let highMid = fft.getEnergy(2600, 5200);
  let treble = fft.getEnergy(5200, 14000);
  
  // Spectral centroid (brightness)
  let spectralCentroid = 0;
  let sumMagnitude = 0;
  for (let i = 0; i < spectrum.length; i++) {
    spectralCentroid += i * spectrum[i];
    sumMagnitude += spectrum[i];
  }
  spectralCentroid = sumMagnitude > 0 ? spectralCentroid / sumMagnitude : 0;
  let normalizedCentroid = map(spectralCentroid, 0, spectrum.length, 0, 1);
  
  // Overall energy
  let energy = fft.getEnergy(20, 14000);
  
  // Beat detection
  beatCutoff *= beatDecayRate;
  if (millis() - beatLast > 20) {
    beatCutoff = max(0, beatCutoff - 0.02);
  }
  
  // Waveform analysis
  let waveform = fft.waveform();
  let waveformVariation = 0;
  for (let i = 0; i < waveform.length; i++) {
    waveformVariation += abs(waveform[i] - waveform[i > 0 ? i-1 : 0]);
  }
  waveformVariation /= waveform.length;
  
  // Update formation progress
  if (formationProgress < 1) {
    formationProgress = min(1, formationProgress + (params.formationSpeed / 5000));
  }
  
  // Dynamic lighting
  ambientLight(10 + energy/10);
  if(params.colorMode === "single") {
    let lightColor = hexToRgb(params.colors[0]);
    let pulseFactor = 1 + bass/255 * 0.5;
    pointLight(
      min(lightColor[0] * pulseFactor, 255),
      min(lightColor[1] * pulseFactor, 255),
      min(lightColor[2] * pulseFactor, 255),
      0, 0, 200
    );
  } else {
    pointLight(
      200 + energy/2,
      200 + energy/2,
      200 + energy/2,
      0, 0, 200
    );
  }
  
  // Reactive glow
  let glowIntensity = params.glow * (1 + energy/255 * 0.5);
  if(params.colorMode === "single") {
    drawingContext.shadowColor = 'rgba(' + hexToRgb(params.colors[0]).join(",") + ',' + (0.3 + energy/510) + ')';
  } else {
    drawingContext.shadowColor = 'rgba(255, 255, 255, ' + (0.3 + energy/510) + ')';
  }
  drawingContext.shadowBlur = glowIntensity;
  
  // Display agents
  for (let i = 0; i < agents.length; i++) {
    let agent = agents[i];
    agent.react(bass, lowMid, mid, highMid, treble, 
               normalizedCentroid, energy, beatCutoff, waveformVariation);
    agent.update();
    agent.display();
  }
}

class Agent {
  constructor(x, y, z, color, brightness, target) {
    this.startPos = createVector(x, y, z);
    this.pos = createVector(x, y, z);
    this.target = createVector(target.x, target.y, target.z);
    this.home = createVector(target.x, target.y, target.z);
    this.vel = createVector();
    this.color = color;
    this.baseColor = color.slice(); // Store original color for reference
    this.brightness = brightness;
    this.baseSize = map(brightness, 0, 255, 1, params.particleSize);
    this.size = this.baseSize;
    this.alpha = map(brightness, 0, 255, 0.5, 0.9);
    this.pulsePhase = random(TWO_PI);
    this.reactScale = random(0.8, 1.2);
    this.freqBand = floor(random(5));
    this.rotationSpeed = random(-0.02, 0.02);
    this.rotation = random(TWO_PI);
    this.formationOffset = random(0.2); // Stagger formation timing
  }
  
  react(bass, lowMid, mid, highMid, treble, centroid, energy, beat, waveformVar) {
    const reactFactor = params.reactivity / 50 * this.reactScale;
    
    let freqEnergy;
    switch(this.freqBand) {
      case 0: freqEnergy = bass; break;
      case 1: freqEnergy = lowMid; break;
      case 2: freqEnergy = mid; break;
      case 3: freqEnergy = highMid; break;
      case 4: freqEnergy = treble; break;
    }
    
    let freqForce = map(freqEnergy, 0, 255, 0, params.pulse * 2 * reactFactor);
    
    // Beat reaction
    if (beat > 0.3) {
      this.vel.add(p5.Vector.random3D().mult(beat * 5 * reactFactor));
      this.size = this.baseSize * (1 + beat * 2);
      this.rotationSpeed = random(-0.05, 0.05) * reactFactor;
    } else {
      // Normal frequency-based movement
      this.pos.z = this.home.z + sin(this.pulsePhase) * freqForce * 20;
      this.size = this.baseSize * (1 + freqEnergy/255 * 0.8 * reactFactor);
    }
    
    // Spectral centroid affects color and rotation
    if(params.colorMode === "brightness") {
      let hueShift = map(centroid, 0, 1, -30, 30);
      let newHue = (map(this.brightness, 0, 255, 0, 360) + hueShift) % 360;
      this.color = HSVtoRGB(newHue/360, 1, 1);
    }
    
    // Waveform variation adds subtle movement
    this.vel.add(p5.Vector.random3D().mult(waveformVar * 0.5 * reactFactor));
    
    // Energy affects transparency
    this.alpha = map(this.brightness, 0, 255, 0.3, 0.9) * (0.7 + energy/255 * 0.6);
    
    // Update pulse phase based on centroid
    this.pulsePhase += 0.03 + centroid * 0.02 * reactFactor;
    this.rotation += this.rotationSpeed * (1 + centroid * 0.5);
  }
  
  update() {
    // Gradual formation animation
    if (formationProgress < 1) {
      let formationT = max(0, min(1, (formationProgress - this.formationOffset) / (1 - this.formationOffset)));
      if (formationT > 0) {
        this.pos.x = lerp(this.startPos.x, this.target.x, formationT);
        this.pos.y = lerp(this.startPos.y, this.target.y, formationT);
        this.pos.z = lerp(this.startPos.z, this.target.z, formationT);
      }
    } else {
      // Normal movement after formation
      this.pos.add(this.vel);
      
      // Return to home position
      let returnStrength = map(params.reactivity, 1, 100, 0.02, 0.005);
      let homeForce = p5.Vector.sub(this.home, this.pos).mult(returnStrength);
      this.vel.add(homeForce);
      this.vel.limit(1.5);
    }
    
    // Size recovery
    this.size = lerp(this.size, this.baseSize, 0.1);
  }
  
  display() {
    push();
    translate(this.pos.x, this.pos.y, this.pos.z);
    rotateZ(this.rotation);
    
    // Outer glow
    fill(this.color[0], this.color[1], this.color[2], this.alpha * 255);
    sphere(this.size * 1.3);
    
    // Inner core
    fill(
      min(this.color[0] + 70, 255),
      min(this.color[1] + 70, 255),
      min(this.color[2] + 70, 255),
      200 * this.alpha
    );
    sphere(this.size * 0.6);
    
    pop();
  }
}

function keyPressed() {
  if (key === 'r' || key === 'R') autoRotate = !autoRotate;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
  </script>
</body>
</html>